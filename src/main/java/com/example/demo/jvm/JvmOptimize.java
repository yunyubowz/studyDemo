package com.example.demo.jvm;

/**
 * jvm调优
 * 如果系统每秒产生1M的对象内存，且这些对象会在30秒变成无引用的,所以避免15次gc后这些对象还没有被minorGC回收就要设置eden区的大小就要超过60M
 * s1区和s2区就要超过30M防止对象不够放，直接存入老年区了
 * jvm调优的本质就是要减少full GC的产生，因为full gc会导致长时间的stw（stop the world）
 * 因为full gc是对新生代，老年代，方法区一起进行对象释放
 *
 * jvm的运行模式
 * 分为两种
 * 解释模式 执行一行jvm字节码就编译成机器码
 * 编译模式 将所有的jvm字节码一次性编译成机器码,然后一次性执行，并开辟内存存储（以便下次存储）
 * 解释模式适合执行热点低的代码
 * 而编译模式适合执行热点高的代码，但是编译模式对内存有要求，所以我们的jvm都是采用混合模式执行，
 * 对于热点执行高的代码，采用编译模式，而热点执行低的代码采用解释模式
 *
 *
 * 对象逃逸分析
 * 分析对象的动态作用域，当一个对象在方法中被定义，是否有可能被外部调用,如果没有可能被外部调用，该对象可能被存储在方法的栈帧上
 * 而不是直接存在堆上
 *
 */
public class JvmOptimize {
}
