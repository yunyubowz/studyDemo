package com.example.demo.jvm;
/**
 * 当一次性存活的对象大小超过当前要放入的survivor区的50%的大小时，由于对象动态年龄判断，这一部分对象都是同龄
 * 对导致这一部分对象会放入老年代，但是这些对象是朝生夕死的对象不应该放入老年区，可以适当调大survivor区的大小
 * 调大jvm的年轻代的大小-Xms(堆的初始化大小) -Xmx(堆的最大大小) -Xmn(堆的年轻代大小) 或者调大survivor的比例
 * -XX:SurvivorRatio=8（表示eden:from:to=8:1:1）
 *
 * 因为eden的对象都是朝生夕死的,超过一定次数未死的都是基本上长时间存活，所以我们可以把年龄15的对象直接放入老年代
 * 把15的年龄调成5，这样可以避免做minorGC对这些对象的复制和移动了浪费资源了‐XX:MaxTenuringThreshold=5
 * 还有些bean的对象可以躲过但是充其量也就几十兆
 *
 * 还有突然剧增的业务量会导致存活的对象大小增多，因为对象动态年龄判断直接进去老年代但是这种几分钟发生一次的行为要将老年代装满起码要半个小时
 * 半个小时做一次fullgc我们是可以接受的
 * 老年代担保机制的老年代剩余空间>每一次minorGC后进入老年代的对象平均大小
 * 因为不是每次都是业务量的剧增场景，会因为之前的正常业务量导致平均大小不大
 * 所以是没有多大可能导致直接fullGC
 * 碎片处理是在fullGC并行处理额而一个小时处理一次fullGC所以可以每一次fullGC后都进行碎片处理
 *
 *
 */
public class GCDemoTest {
}
